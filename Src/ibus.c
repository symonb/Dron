/*
 * ibus.c
 *
 *  Created on: 25.01.2021
 *      Author: filip
 */
#include "stm32f4xx.h"
#include "global_constants.h"
#include "global_variables.h"
#include "global_functions.h"
#include "flash.h"
#include "ibus.h"

volatile uint8_t rxBuf[32];
static uint8_t rxindex = 0;

static void failsafe_RX();

void DMA2_Stream5_IRQHandler(void)
{
	// if channel4 transfer is completed:

	// if channel5 transfer is completed:
	if (DMA2->HISR & DMA_HISR_TCIF5)
	{
		DMA2->HIFCR |= DMA_HIFCR_CTCIF5;
		DMA2_Stream5->CR &= ~DMA_SxCR_EN;

		ibus_received = true;
		if (!imu_received)
		{
			EXTI->IMR |= EXTI_IMR_MR4; // unblock IMU reading
		}
	}
}
// for DMA:
void USART1_IRQHandler(void)
{

	// RDR not empty flag:
	if (USART_SR_RXNE & USART1->SR)
	{

		// probably not necessary:

		//		static timeUs_t last_time;
		//		static timeUs_t gap_time;
		//		gap_time = get_Global_Time() - last_time;
		//		if (rxindex != 0 && gap_time > 500){
		//			rxindex = 0;
		//
		//
		//		}
		//		last_time += gap_time;

		//	read actual value of I-BUS (Interrupt flag will be automatically removed):
		rxBuf[rxindex] = USART1->DR;
		if (rxindex == 1 && rxBuf[rxindex] == 0x40)
		{

			// block USART1 interrupt and IMU reading until DMA reading finish and data are processed:
			USART1->CR1 &= ~USART_CR1_RXNEIE;
			EXTI->IMR &= ~EXTI_IMR_MR4;
			DMA2_Stream5->CR |= DMA_SxCR_EN;
		}
		else if (rxindex == 0 && rxBuf[rxindex] != 0x20)
		{
			rxindex = 0;
		}
		else if (rxindex == 1 && rxBuf[rxindex] != 0x40)
		{
			rxindex = 0;
		}
		else
		{
			// if header is right increase rxindex
			rxindex++;
		}
	}
	// idle detection flag:
	if (0 != (USART_SR_IDLE & USART1->SR))
	{
		USART1->DR;

		if (!ibus_received)
		{
			USART1->CR1 |= USART_CR1_RXNEIE;
			DMA2_Stream5->CR &= ~DMA_SxCR_EN;
		}
	}
}

////for Interrupt:
// void USART1_IRQHandler(void) {
//
//
//
//	//	check if interrupt was generated by right flag:
//	if (0 != (USART_SR_RXNE & USART1->SR)) {
//		//	read actual value of I-BUS (flag will be automatically removed):
//
//		current_time = get_Global_Time();
//		gap_time = current_time - last_time;
//		last_time = current_time;
//		//check if gap is bigger than 0.5 [ms]
//		if (gap_time > SEC_TO_US(0.5)) {
//			rxindex = 0;
//		}
//		rxBuf[rxindex] = USART1->DR;
//		if (rxindex == 31) {
//			ibus_received = 1;
//			//block receiving new data until old data are processed:
//			USART1->CR1 &= ~USART_CR1_RXNEIE;
//			pok++;
//		}	//	waiting for header 0x2040:
//		else if (rxindex == 0 && rxBuf[rxindex] != 0x20) {
//			rxindex = 0;
//		} else if (rxindex == 1 && rxBuf[rxindex] != 0x40) {
//			rxindex = 0;
//		}
//		else {	//if header is right increase rxindex
//			rxindex++;
//		}
//	}
//	//idle detection flag:
//
//	 if (0 != (USART_SR_IDLE & USART1->SR)) {
//		 USART1->DR;
//			if (ibus_received == 0) {
//				USART1->CR1 |= USART_CR1_RXNEIE;
//			}
//			pok1++;
//		}
//	}

bool Ibus_save(timeUs_t current_time)
{
	uint16_t checksum = 0xFFFF;

	if ((current_time - time_flag3_1) >= SEC_TO_US(MAX_NO_SIGNAL_TIME))
	{
		FailSafe_status = RX_TIMEOUT;
		EXTI->SWIER |= EXTI_SWIER_SWIER15;
	}

	// checking checksum and rewriting rxBuf to channels:
	if (ibus_received)
	{

		time_flag3_1 = current_time;
		checksum = 0xFFFF;
		for (int8_t i = 0; i < 30; i++)
		{
			checksum -= rxBuf[i];
		}
		if (checksum == ((rxBuf[31] << 8) + rxBuf[30]))
		{
			for (int8_t i = 0; i < CHANNELS; i++)
			{
				channels_previous_values[i] = channels[i];
				channels[i] = (rxBuf[2 * (i + 1) + 1] << 8) + rxBuf[2 * (i + 1)];
			}

			failsafe_RX();
			Throttle = channels[2];

			if (channels[6] < 1400)
			{
				flight_mode = FLIGHT_MODE_ACRO;
				turn_OFF_RED_LED();
				turn_ON_BLUE_LED();
			}
			else if (channels[6] > 1450)
			{
				flight_mode = FLIGHT_MODE_STABLE;
				turn_OFF_BLUE_LED();
				turn_ON_RED_LED();
			}

			if (channels[7] >= 1400 && channels[7] < 1700)
			{
				BLACKBOX_STATUS = BLACKBOX_COLLECT_DATA;
			}
			else if (channels[7] >= 1700)
			{
				BLACKBOX_STATUS = BLACKBOX_IDLE;
			}
			else
			{
				BLACKBOX_STATUS = BLACKBOX_IDLE;
			}
		}

		//	unlock receiving new data from i-Bus:
		rxindex = 0;
		ibus_received = false;
		USART1->CR1 |= USART_CR1_RXNEIE;

		return true;
	}
	return false;
}

static void failsafe_RX()
{

#if defined(USE_PREARM)
	// Arming switch:
	if (channels[4] <= ARM_VALUE)
	{
		FailSafe_status = DISARMED;
		EXTI->SWIER |= EXTI_SWIER_SWIER15;
		arming_status = -1;
		if (channels[8] > PREARM_VALUE)
		{
			arming_status = 0;
		}
	}
	else if (channels[0] <= MIN_RX_SIGNAL || channels[0] >= MAX_RX_SIGNAL || channels[1] <= MIN_RX_SIGNAL || channels[1] >= MAX_RX_SIGNAL || channels[2] <= MIN_RX_SIGNAL || channels[2] >= MAX_RX_SIGNAL || channels[3] <= MIN_RX_SIGNAL || channels[3] >= MAX_RX_SIGNAL)
	{

		FailSafe_status = INCORRECT_CHANNELS_VALUES;
		EXTI->SWIER |= EXTI_SWIER_SWIER15;
	}
	else if (arming_status == 0 || arming_status == 1)
	{
		arming_status = 1;
		motor_1_value_pointer = &motor_1_value;
		motor_2_value_pointer = &motor_2_value;
		motor_3_value_pointer = &motor_3_value;
		motor_4_value_pointer = &motor_4_value;
	}
#else
	// Arming switch:
	if (channels[4] <= ARM_VALUE)
	{
		ARMING_STATUS = DISARMED;
		motor_1_value_pointer = &MOTOR_OFF;
		motor_2_value_pointer = &MOTOR_OFF;
		motor_3_value_pointer = &MOTOR_OFF;
		motor_4_value_pointer = &MOTOR_OFF;
	}
	else if (channels[0] <= MIN_RX_SIGNAL ||
			 channels[0] >= MAX_RX_SIGNAL ||
			 channels[1] <= MIN_RX_SIGNAL ||
			 channels[1] >= MAX_RX_SIGNAL ||
			 channels[2] <= MIN_RX_SIGNAL ||
			 channels[2] >= MAX_RX_SIGNAL ||
			 channels[3] <= MIN_RX_SIGNAL ||
			 channels[3] >= MAX_RX_SIGNAL)
	{

		for (uint8_t i = 0; i < CHANNELS; i++)
		{
			channels[i] = channels_previous_values[i];
		}

		FailSafe_status = INCORRECT_CHANNELS_VALUES;
		EXTI->SWIER |= EXTI_SWIER_SWIER15;
	}
	else
	{
		ARMING_STATUS = ARMED;
		motor_1_value_pointer = &motor_1_value;
		motor_2_value_pointer = &motor_2_value;
		motor_3_value_pointer = &motor_3_value;
		motor_4_value_pointer = &motor_4_value;
	}
#endif
}
